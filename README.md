# MC迭代法的基本思想和流程

​		MC, 全名蒙特卡洛(Monte Carlo), 是分子动力学中常用的一种方法, 其基本思想是随机大量取样, 从中选择最好的解, 样本越大越接近准确解. 在分子动力学中, MC的应用范围极广, 包括吸附, 溶液的一系列领域都有应用, 但是那些都不在今天的讨论范围之内, 今天我们将撰写一个最基础的MC迭代程序, 不考虑化学势差, 不考虑MC/MD混合模拟, 以获得一个比起随机替换原子更有序的原子模型, 即一个具有短程有序的合金模型.

​		在开始写程序之前, 还需要给大家介绍一下Metropolis判据, 这个判据的的基本思想是以概率接受新状态, 这么说可能会有点抽象, 没关系, 我们结合以下流程图进行分析:

​		![](./picture/流程图.png)

​		而上图中的P按照如下公式进行计算:

![](./picture/equation.png)

​		上式中, k为热力学常数, 也叫**玻尔兹曼常数**, 在SI单位制下为**K=1.380649 × 10-23 J/K**, 在我们会用到的metal单位制中, 能量的单位为ev, 而温度依然是K, 这时**K = 8.617343e-5 ev/k**,T为MC迭代时候的温度, **E(i+1)**是交换原子之后的模型势能, 而**E(i)**是交换原子之前的模型势能. 讲完基础知识之后, 我们来看看上面的流程图:

​		首先第一步, 随机交换模型中2个原子的位置, 即原子I和原子J, 计算交换前后的势能**E(i+1)**和**E(i)**, 进行判别, 如果发现交换之后模型的势能小于交换之前的, 即**E(i+1) < E(i)**, 那么我们就接受这一次的交换, 并用交换之后的模型当成新的起点重新进行MC迭代, 那么如果发现交换之后, 原子的势能更高了, 那么, 这个交换是否就应该被丢弃不用? 并不是, **Metropolis**提出了一种方法, 如果发现交换前后的势能升高, 就计算**Metropolis**判据P, 这个P是一个(0, 1)之间的数, 计算公式如上图所示, 之后再用一个在(0, 1)上均匀分布的随机数R, 去与P进行比较, 判断是否接受这个交换.

​		我们这里可以看出, 在低温下, 只能接受与当前状态能差较小的的模型, 高温下可接受与当前状态能差较大的模型, 而这也与我们的认知是比较相符的, 而至于为什么是图二中的数学公式? 我也不知道, 但是这个公式背后是有非常深刻和严谨的数学逻辑的, 凡是涉及MC迭代的程序, 包括**LAMMPS**中的**fix atom/swap**命令, 都会利用这个判据进行**重要性采样**, 在很多研究短程有序和MC模拟的分子动力学文章中, 这个公式也反复的出现, 同学们无须知道这个公式如何推导, 只需要会用和编程即可.



# MC迭代法的编程实现

​		想要使用本程序, 需要严格按照Fortran的namelist方法编写相关输入文件, 在src文件夹下面有一个parameter.nml文件示范.

​		对应的标准的namelist格式的输入文件如下:

```fortran
&PARAMETER
potentialName = '../potential/CoCuFeNiPd.set'
modelName = '../model/CoCuFeNiPd-0.txt'
temprature = 300.d0
iterSteps = 60000
/

```

​		 然后是运行方法, 我这里依然是写了一个小脚本, 用于快速设置并行运行环境.

```shell
#!/bin/bash
export OMP_NUM_THREADS=$1
./mc $2	
```

​		**$1**和**$2**会被命令行的第一个参数和第二个参数替换, 这里我们假设应该使用4核并行 + 参数文件名为parameter.nml, 那么运行方法就应该是:

```shell
./run.sh 4 parameter.nml
```

​		现在我们的程序正以4核并行进行MC迭代运算!

![](.\picture\运行过程.png)

​		当然这里迭代步数太少, 看不出什么, 虽然确实模型的势能在不断的减少. 这里我直接放上我20W次迭代前后的模型和迭代过程中势能曲线的变化曲线图, 以及CPU利用率的图片:

![](./picture/model.png)

![](./picture/EnergyCurve.png)

![](./picture/CPU.png)

​		可以看到, 非常完美, 随着迭代的进行模型势能不断下降, 并且在迭代了20w次之后, 模型出现了显著的元素偏聚和元素分离, 而且在计算过程中, CPU的利用率始终在98%以上, 这个利用率是串行程序根本无法达到的程度. 至于元素偏聚是不是和文章中的趋势一样, 就请同学们自行阅读文献进行对比了.

​		那么到目前为止, 我们利用我们的知识完成了一个最基础最原始的MC迭代程序的编写, 但是这个程序还有很多可以提高的空间, 比如采用**MPI**实现并行, 提高并行效率, 或者优化随机数算法, 使其更快生成随机数, 或者一次可以不选择2个原子, 而是选择4个或者8个乃至更多个原子进行交换, 然后再进行**Metropolis**判断, 又或者仿照**LAMMPS**中的**fix atom/swap**, 指定对2类原子进行交换, 这一点使用Fortran的内置函数**pack()**, 再加上一些小技巧就可以很轻松的实现, 模仿**LAMMPS**的输出加一个写出log文件的子程序也是一个非常不错的想法. 然后再说明一下, 这种最原始的MC迭代算法效率极低, 基本上迭代到了50w步之后,  模型的势能就几乎停滞不前了, 无法再进一步下降了, 需要想办法从各个方面进一步优化这个算法. 代码和模型文件将在文章的最后一并给出.
